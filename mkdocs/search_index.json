{
    "docs": [
        {
            "location": "/", 
            "text": "Hot Module Replacement Tutorial\n\n\nPeque\u00f1o tutorial sobre configuraci\u00f3n de Webpack, webpack-dev-server, ES6, React y Cordova\n\n\n\n\nCreaci\u00f3n del bundle\n\n\nInstalaci\u00f3n y configuraci\u00f3n de webpack-dev-server\n\n\nCompilando desde ES6", 
            "title": "Inicio"
        }, 
        {
            "location": "/#hot-module-replacement-tutorial", 
            "text": "Peque\u00f1o tutorial sobre configuraci\u00f3n de Webpack, webpack-dev-server, ES6, React y Cordova   Creaci\u00f3n del bundle  Instalaci\u00f3n y configuraci\u00f3n de webpack-dev-server  Compilando desde ES6", 
            "title": "Hot Module Replacement Tutorial"
        }, 
        {
            "location": "/bundle/", 
            "text": "Creaci\u00f3n del Bundle\n\n\nWebpack genera un archivo llamado bundle, donde almacenar\u00e1 las dependencias de nuestro proyecto a partir de los imports de este mismo. \n\n\nEn este tutorial usaremos \nyarn\n como gestor de paquetes, por lo que empezamos inicializando el proyecto creando el \npackage.json\n:\n\n\nyarn init\n\n\n\n\nSeguiremos con la instalaci\u00f3n de \nwebpack\n:\n\n\n$ yarn add webpack\n\n\n\n\nAhora configuraremos \nwebpack\n para la creaci\u00f3n de nuestro bundle. Crearemos el archivo \nwebpack.config.js\n y a\u00f1adiremos la siguiente configuraci\u00f3n:\n\n\nconst path = require('path');\n\nmodule.exports = {\n    context: path.resolve(__dirname),\n    devtool: \"eval-source-map\",\n    entry: {\n        main: './src/index.js'\n     },\n    output: {\n        path: path.resolve(__dirname, 'dist'),\n        filename: '[name].js',\n    }\n};\n\n\n\n\n\ncontext\n: ser\u00e1 el directorio base a partir del cual se se resuelven los puntos de entrada y los \nloaders\n\n\ndevtool\n: Controla como quieres que se generen los \nsource maps\n \nDocumentaci\u00f3n\n. Es importante controlar este valor ya que ser\u00e1 el que nos permita debugar la salida generada por \nwebpack\n\n\nentry\n: entrada desde la que se generar\u00e1 el \nbundle\n. Es el archivo de inicio de nuestra aplicaci\u00f3n, a partir del cual \nwebpack\nir\u00e1 construyendo el \nbundle\n \"tirando\" de las dependencias de los m\u00f3dulos que importamos.\n\n\noutput\n: controla donde y como queremos que se generen las salidas o salida de nuestro \nbundle\n y resto de archivos necesarios en nuestra aplicaci\u00f3n.\n\n\n\n\nCon la configuraci\u00f3n b\u00e1sica anterior, nos faltar\u00eda tener los archivos \nindex.js\n y sus dependencias. En el \nrepositorio\n preparado para este tutorial podr\u00e1s encontrar estos arhivos ya preparados.\n\n\nCrearemos una tarea de \nnpm\n que nos ejecute \nwebpack\n y nos genere nuestro \nbundle\n:\n\n\n\"build\": \"webpack\"\n\n\n\nSi ejecutamos este script:\n\n\n npm run build\n\n\n\nconstruiremos nuestro \nbundle\n que ser\u00e1 guardado en la ruta que hemos indicado en el \noutput\n:\n\n\n webpack\n\nHash: 019c0dd0b804295531e4\nVersion: webpack 2.6.1\nTime: 79ms\n  Asset     Size  Chunks             Chunk Names\nmain.js  4.49 kB       0  [emitted]  main\n   [0] ./src/App.js 149 bytes {0} [built]\n   [1] ./src/index.js 84 bytes {0} [built]", 
            "title": "Creaci\u00f3n del bundle"
        }, 
        {
            "location": "/bundle/#creacion-del-bundle", 
            "text": "Webpack genera un archivo llamado bundle, donde almacenar\u00e1 las dependencias de nuestro proyecto a partir de los imports de este mismo.   En este tutorial usaremos  yarn  como gestor de paquetes, por lo que empezamos inicializando el proyecto creando el  package.json :  yarn init  Seguiremos con la instalaci\u00f3n de  webpack :  $ yarn add webpack  Ahora configuraremos  webpack  para la creaci\u00f3n de nuestro bundle. Crearemos el archivo  webpack.config.js  y a\u00f1adiremos la siguiente configuraci\u00f3n:  const path = require('path');\n\nmodule.exports = {\n    context: path.resolve(__dirname),\n    devtool: \"eval-source-map\",\n    entry: {\n        main: './src/index.js'\n     },\n    output: {\n        path: path.resolve(__dirname, 'dist'),\n        filename: '[name].js',\n    }\n};   context : ser\u00e1 el directorio base a partir del cual se se resuelven los puntos de entrada y los  loaders  devtool : Controla como quieres que se generen los  source maps   Documentaci\u00f3n . Es importante controlar este valor ya que ser\u00e1 el que nos permita debugar la salida generada por  webpack  entry : entrada desde la que se generar\u00e1 el  bundle . Es el archivo de inicio de nuestra aplicaci\u00f3n, a partir del cual  webpack ir\u00e1 construyendo el  bundle  \"tirando\" de las dependencias de los m\u00f3dulos que importamos.  output : controla donde y como queremos que se generen las salidas o salida de nuestro  bundle  y resto de archivos necesarios en nuestra aplicaci\u00f3n.   Con la configuraci\u00f3n b\u00e1sica anterior, nos faltar\u00eda tener los archivos  index.js  y sus dependencias. En el  repositorio  preparado para este tutorial podr\u00e1s encontrar estos arhivos ya preparados.  Crearemos una tarea de  npm  que nos ejecute  webpack  y nos genere nuestro  bundle :  \"build\": \"webpack\"  Si ejecutamos este script:   npm run build  construiremos nuestro  bundle  que ser\u00e1 guardado en la ruta que hemos indicado en el  output :   webpack\n\nHash: 019c0dd0b804295531e4\nVersion: webpack 2.6.1\nTime: 79ms\n  Asset     Size  Chunks             Chunk Names\nmain.js  4.49 kB       0  [emitted]  main\n   [0] ./src/App.js 149 bytes {0} [built]\n   [1] ./src/index.js 84 bytes {0} [built]", 
            "title": "Creaci\u00f3n del Bundle"
        }, 
        {
            "location": "/webpackdevserver/", 
            "text": "Webpack-dev-server\n\n\nyarn add webpack-dev-server\n\n\n\ny creamos una orden en los scripts del package.json para ejecutarlo:\n\n\n\u201cdev\u201d: \u201cwebpack-dev-server\u201d\n\n\n\nEste es un servidor de desarrollo que publicar\u00e1 los recursos de webpack para que sean accesibles desde el navegador. Lo que hace es crear un servidor de desarrollo que publica los recursos. Para ello configuramos en el webpack.config.js los siguientes cambios:\n\n\ndevServer: {\n    contentBase: path.join(__dirname, \"platforms/android/assets/www\"),\n    compress: true,\n    port: 3000,\n    publicPath: '/js/'  \n},\n\n\n\n\n\ncontentBase\n: carpeta desde la que se publicar\u00e1 la ra\u00edz de nuestro contenido\n\n\ncompress\n: comprime como gzip todo el contenido servido\n\n\nport\n: el puerto donde se publicar\u00e1 http://localhost:\n\n\npublicPath\n: el path donde ser\u00e1 publicados los recursos bundled, en nuestro caso que el valor es /js/ la ruta final de los archivos bundled ser\u00e1 http://localhost:\n/js/\n\n\n\n\nSi ejecutamos npm dev la salida nos dar\u00e1:\n\n\n   \n webpack-dev-server\n\n   Project is running at http://localhost:3000/\n   webpack output is served from /js/\n   Content not from webpack is served from /home/michogarcia/geomati.co/TMB/dev/hmr-tutorial/dist\n   Hash: b6f42794026ca8bf8d0a\n   Version: webpack 2.6.1\n   Time: 928ms\n     Asset    Size  Chunks                    Chunk Names\n   main.js  841 kB       0  [emitted]  [big]  main\n   chunk    {0} main.js (main) 302 kB [entry] [rendered]\n      [35] (webpack)-dev-server/client?http://localhost:3000 5.68 kB {0} [built]\n      [36] ./src/index.js 84 bytes {0} [built]\n      [37] ./~/ansi-html/index.js 4.26 kB {0} [built]\n      [38] ./~/ansi-regex/index.js 135 bytes {0} [built]\n      [40] ./~/events/events.js 8.33 kB {0} [built]\n      [41] ./~/html-entities/index.js 231 bytes {0} [built]\n      [48] ./~/querystring-es3/index.js 127 bytes {0} [built]\n      [77] ./~/strip-ansi/index.js 161 bytes {0} [built]\n      [78] ./~/url/url.js 23.3 kB {0} [built]\n      [79] ./~/url/util.js 314 bytes {0} [built]\n      [80] (webpack)-dev-server/client/overlay.js 3.73 kB {0} [built]\n      [81] (webpack)-dev-server/client/socket.js 897 bytes {0} [built]\n      [83] (webpack)/hot/emitter.js 77 bytes {0} [built]\n      [84] ./src/App.js 149 bytes {0} [built]\n      [85] multi (webpack)-dev-server/client?http://localhost:3000 ./src/index.js 40 bytes {0} [built]\n        + 71 hidden modules\n   webpack: Compiled successfully.\n\n\n\nwebpack-dev-server\n crear\u00e1 el \nbundle\n tal y como hemos definido y lo publicar\u00e1 en las rutas que hayamos configurado. Si nos \nfijamos en la salida, el propio servidor nos est\u00e1 indicando donde podemos encontrar nuestros \nbundles\n publicados:\n\n\nProject is running at http://localhost:3000/\n\n\n\nPodremos ver un resumen en:\n\n\nhttp://localhost:3000/webpack-dev-server\n\n\ny veremos nuestro \nbundle\n publicado en:\n\n\nhttp://localhost:3000/main.js\n\n\nPara comprobar como \nwebpack-dev-server\n nos ayuda en el desarrollo generando el \nbundle\n de manera din\u00e1mica cada vez que se detecta un cambio\ncrearemos un archivo \nindex.html\n en la carpeta \ndist\n que ser\u00e1 la carpeta que publicaremos.\n\n\nHaremos algunos cambios en la creaci\u00f3n del \nbundle\n para adaptarlo a la nueva estructura de carpetas. Para ello, modificaremos la salida:\n\n\noutput: {\n   path: path.resolve(__dirname, 'dist/js'),\n   filename: '[name].js',\n},\n\n\n\nindic\u00e1ndole la nueva ruta \ndist/js\n. Recordad que el raiz de nuestro \nwebpack-dev-server\n ser\u00e1 la propia carpeta \ndist\n y que el\n\npublicPath\n apunta a la que ser\u00e1 la carpeta \ndist/js\n donde se guardar\u00e1 el \nbundle\n que se genera.\n\n\nSi ejecutamos de nuevo:\n\n\nnpm run dev\n\n\n\npodremos observar que ahora la ruta de nuestro \nbundle\n (main.js) est\u00e1 en:\n\n\nhttp://localhost:3000/js/main.js\n\n\nSi vamos a la carpeta \ndist\n comprobaremos que no se ha creado ning\u00fan archivo en la misma, eso es porque en todo momento\n\nwebpack-dev-server\n est\u00e1 publicando el \nbundle\n desde memoria.\n\n\nAhora crearemos una \ndiv id=rootElement\n en el \nindex.html\n para poder visualizar como trabaja \nwebpack-dev-server\n.\n\n\nbody\n\n    \ndiv id=\"rootElement\"\n/div\n\n\n/body\n\n\n\n\nIncluiremos en nuestra \nApp.js\n la funcionalidad que modifique el contenido de esa \ndiv\n\n\nconstructor() {\n    document.getElementById('rootElement').innerHTML = '\nspan\nMira, \u00a1\u00a1funciona!!\n/span\n';\n}\n\n\n\ny haremos que el \nindex.html\n cargue nuestro \nbundle\n.\n\n\nscript type=\"text/javascript\" src=\"./js/main.js\"\n/script\n\n\n\n\nSi modificamos nuestra \nApp.js\n por ejemplo cambiando el texto, veremos como \nwebpack-dev-server\n \"compila\" de nuevo\n\n\n webpack: Compiling...\n Hash: e5d45663418c4a61284b\n Version: webpack 2.6.1\n Time: 146ms\n   Asset    Size  Chunks                    Chunk Names\n main.js  841 kB       0  [emitted]  [big]  main\n chunk    {0} main.js (main) 302 kB [entry] [rendered]\n    [84] ./src/App.js 201 bytes {0} [built]\n      + 85 hidden modules\n webpack: Compiled successfully.\n\n\n\ny publica el nuevo \nbundle\n aplicando los cambios autom\u00e1ticamente sin refrescar.", 
            "title": "Instalaci\u00f3n y configuraci\u00f3n de webpack-dev-server"
        }, 
        {
            "location": "/webpackdevserver/#webpack-dev-server", 
            "text": "yarn add webpack-dev-server  y creamos una orden en los scripts del package.json para ejecutarlo:  \u201cdev\u201d: \u201cwebpack-dev-server\u201d  Este es un servidor de desarrollo que publicar\u00e1 los recursos de webpack para que sean accesibles desde el navegador. Lo que hace es crear un servidor de desarrollo que publica los recursos. Para ello configuramos en el webpack.config.js los siguientes cambios:  devServer: {\n    contentBase: path.join(__dirname, \"platforms/android/assets/www\"),\n    compress: true,\n    port: 3000,\n    publicPath: '/js/'  \n},   contentBase : carpeta desde la que se publicar\u00e1 la ra\u00edz de nuestro contenido  compress : comprime como gzip todo el contenido servido  port : el puerto donde se publicar\u00e1 http://localhost:  publicPath : el path donde ser\u00e1 publicados los recursos bundled, en nuestro caso que el valor es /js/ la ruta final de los archivos bundled ser\u00e1 http://localhost: /js/   Si ejecutamos npm dev la salida nos dar\u00e1:       webpack-dev-server\n\n   Project is running at http://localhost:3000/\n   webpack output is served from /js/\n   Content not from webpack is served from /home/michogarcia/geomati.co/TMB/dev/hmr-tutorial/dist\n   Hash: b6f42794026ca8bf8d0a\n   Version: webpack 2.6.1\n   Time: 928ms\n     Asset    Size  Chunks                    Chunk Names\n   main.js  841 kB       0  [emitted]  [big]  main\n   chunk    {0} main.js (main) 302 kB [entry] [rendered]\n      [35] (webpack)-dev-server/client?http://localhost:3000 5.68 kB {0} [built]\n      [36] ./src/index.js 84 bytes {0} [built]\n      [37] ./~/ansi-html/index.js 4.26 kB {0} [built]\n      [38] ./~/ansi-regex/index.js 135 bytes {0} [built]\n      [40] ./~/events/events.js 8.33 kB {0} [built]\n      [41] ./~/html-entities/index.js 231 bytes {0} [built]\n      [48] ./~/querystring-es3/index.js 127 bytes {0} [built]\n      [77] ./~/strip-ansi/index.js 161 bytes {0} [built]\n      [78] ./~/url/url.js 23.3 kB {0} [built]\n      [79] ./~/url/util.js 314 bytes {0} [built]\n      [80] (webpack)-dev-server/client/overlay.js 3.73 kB {0} [built]\n      [81] (webpack)-dev-server/client/socket.js 897 bytes {0} [built]\n      [83] (webpack)/hot/emitter.js 77 bytes {0} [built]\n      [84] ./src/App.js 149 bytes {0} [built]\n      [85] multi (webpack)-dev-server/client?http://localhost:3000 ./src/index.js 40 bytes {0} [built]\n        + 71 hidden modules\n   webpack: Compiled successfully.  webpack-dev-server  crear\u00e1 el  bundle  tal y como hemos definido y lo publicar\u00e1 en las rutas que hayamos configurado. Si nos \nfijamos en la salida, el propio servidor nos est\u00e1 indicando donde podemos encontrar nuestros  bundles  publicados:  Project is running at http://localhost:3000/  Podremos ver un resumen en:  http://localhost:3000/webpack-dev-server  y veremos nuestro  bundle  publicado en:  http://localhost:3000/main.js  Para comprobar como  webpack-dev-server  nos ayuda en el desarrollo generando el  bundle  de manera din\u00e1mica cada vez que se detecta un cambio\ncrearemos un archivo  index.html  en la carpeta  dist  que ser\u00e1 la carpeta que publicaremos.  Haremos algunos cambios en la creaci\u00f3n del  bundle  para adaptarlo a la nueva estructura de carpetas. Para ello, modificaremos la salida:  output: {\n   path: path.resolve(__dirname, 'dist/js'),\n   filename: '[name].js',\n},  indic\u00e1ndole la nueva ruta  dist/js . Recordad que el raiz de nuestro  webpack-dev-server  ser\u00e1 la propia carpeta  dist  y que el publicPath  apunta a la que ser\u00e1 la carpeta  dist/js  donde se guardar\u00e1 el  bundle  que se genera.  Si ejecutamos de nuevo:  npm run dev  podremos observar que ahora la ruta de nuestro  bundle  (main.js) est\u00e1 en:  http://localhost:3000/js/main.js  Si vamos a la carpeta  dist  comprobaremos que no se ha creado ning\u00fan archivo en la misma, eso es porque en todo momento webpack-dev-server  est\u00e1 publicando el  bundle  desde memoria.  Ahora crearemos una  div id=rootElement  en el  index.html  para poder visualizar como trabaja  webpack-dev-server .  body \n     div id=\"rootElement\" /div  /body   Incluiremos en nuestra  App.js  la funcionalidad que modifique el contenido de esa  div  constructor() {\n    document.getElementById('rootElement').innerHTML = ' span Mira, \u00a1\u00a1funciona!! /span ';\n}  y haremos que el  index.html  cargue nuestro  bundle .  script type=\"text/javascript\" src=\"./js/main.js\" /script   Si modificamos nuestra  App.js  por ejemplo cambiando el texto, veremos como  webpack-dev-server  \"compila\" de nuevo   webpack: Compiling...\n Hash: e5d45663418c4a61284b\n Version: webpack 2.6.1\n Time: 146ms\n   Asset    Size  Chunks                    Chunk Names\n main.js  841 kB       0  [emitted]  [big]  main\n chunk    {0} main.js (main) 302 kB [entry] [rendered]\n    [84] ./src/App.js 201 bytes {0} [built]\n      + 85 hidden modules\n webpack: Compiled successfully.  y publica el nuevo  bundle  aplicando los cambios autom\u00e1ticamente sin refrescar.", 
            "title": "Webpack-dev-server"
        }, 
        {
            "location": "/babel/", 
            "text": "Compilando desde ES6\n\n\nComo ya os habr\u00e9is fijado, hemos escrito nuestro c\u00f3digo usando ES6. Aunque cada vez m\u00e1s los navegadores incorporan pr\u00e1cticamente \n todas las funcionalidades del nuevo estandar, pero en algunso casos querremos compilar nuestro c\u00f3digo desde ES6 a ES5. \n\n\nPara ello utilizaremos \nBabel\n un compilador de JavaScript que nos permite realizar esta compilaci\u00f3n.\n\n\nTendremos instalar algunos paquetes y realizar algunos cambios en la configuraci\u00f3n del \nwebpack\n.\n\n\nPara realizar la compilaci\u00f3n usaremos los \nloaders\n de \nwebpack\n. Los loaders se encargan de realizar ciertas operaciones \n durante la creaci\u00f3n del \nbundle\n.\n\n\nPrimero instalamos los paquetes necesarios para la compilaci\u00f3n:\n\n\nyarn add babel-core babel-loader --dev\n\n\n\ny a\u00f1adimos la configuraci\u00f3n necesaria:\n\n\n module: {\n     rules: [\n         {\n             test: /\\.(js|jsx)$/,\n             exclude: [/node_modules/],\n             use: ['babel-loader'],\n         }\n     ],\n },\n\n\n\n\n\nmodule\n: se encarga de definir los t\u00edpos de m\u00f3dulos que tenemos dentro del proyecto y nos permite configurar diferentes\n tratamientos.\n\n\nrules\n: reglas que aplicar\u00e1n configuraciones sobre aquellos m\u00f3dulos que las cumplan. Se trata de un \nArray\n en el que se van incluyendo\n las diferentes reglas\n\n\n\n\nUna \nrule\n viene definida por un objeto que a su vez tiene unas propiedades, en nuestro caso:\n\n\n\n\ntest\n: la regla que se aplicar\u00e1 a los recursos, en nuestro caso es una expresi\u00f3n regular que aplica la configuraci\u00f3n \n definida a los archivos con extensi\u00f3n \n.js\n o \n.jsx\n. \nDocumentaci\u00f3n Oficial\n\n\nexclude\n: \nNO\n se aplica a los recursos que cumplan la condici\u00f3n, en nuestro caso que se encuentren en el path \nnode_modules\n\n evitando as\u00ed la compilaci\u00f3n de los archivos que se encuentran en esa carpeta\n\n\nuse\n: listado de \nloaders\n que ser\u00e1n aplicados a los recursos\n\n\n\n\nAhora nuestro c\u00f3digo estar\u00e1 preparado para los navegadores que no implementen todav\u00eda ES6.", 
            "title": "Compilando desde ES6"
        }, 
        {
            "location": "/babel/#compilando-desde-es6", 
            "text": "Como ya os habr\u00e9is fijado, hemos escrito nuestro c\u00f3digo usando ES6. Aunque cada vez m\u00e1s los navegadores incorporan pr\u00e1cticamente \n todas las funcionalidades del nuevo estandar, pero en algunso casos querremos compilar nuestro c\u00f3digo desde ES6 a ES5.   Para ello utilizaremos  Babel  un compilador de JavaScript que nos permite realizar esta compilaci\u00f3n.  Tendremos instalar algunos paquetes y realizar algunos cambios en la configuraci\u00f3n del  webpack .  Para realizar la compilaci\u00f3n usaremos los  loaders  de  webpack . Los loaders se encargan de realizar ciertas operaciones \n durante la creaci\u00f3n del  bundle .  Primero instalamos los paquetes necesarios para la compilaci\u00f3n:  yarn add babel-core babel-loader --dev  y a\u00f1adimos la configuraci\u00f3n necesaria:   module: {\n     rules: [\n         {\n             test: /\\.(js|jsx)$/,\n             exclude: [/node_modules/],\n             use: ['babel-loader'],\n         }\n     ],\n },   module : se encarga de definir los t\u00edpos de m\u00f3dulos que tenemos dentro del proyecto y nos permite configurar diferentes\n tratamientos.  rules : reglas que aplicar\u00e1n configuraciones sobre aquellos m\u00f3dulos que las cumplan. Se trata de un  Array  en el que se van incluyendo\n las diferentes reglas   Una  rule  viene definida por un objeto que a su vez tiene unas propiedades, en nuestro caso:   test : la regla que se aplicar\u00e1 a los recursos, en nuestro caso es una expresi\u00f3n regular que aplica la configuraci\u00f3n \n definida a los archivos con extensi\u00f3n  .js  o  .jsx .  Documentaci\u00f3n Oficial  exclude :  NO  se aplica a los recursos que cumplan la condici\u00f3n, en nuestro caso que se encuentren en el path  node_modules \n evitando as\u00ed la compilaci\u00f3n de los archivos que se encuentran en esa carpeta  use : listado de  loaders  que ser\u00e1n aplicados a los recursos   Ahora nuestro c\u00f3digo estar\u00e1 preparado para los navegadores que no implementen todav\u00eda ES6.", 
            "title": "Compilando desde ES6"
        }
    ]
}