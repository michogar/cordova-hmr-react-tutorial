{
    "docs": [
        {
            "location": "/", 
            "text": "Hot Module Replacement Tutorial\n\n\nPeque\u00f1o tutorial sobre configuraci\u00f3n de Webpack, webpack-dev-server, ES6, React y Cordova\n\n\n\n\nCreaci\u00f3n del bundle\n\n\nInstalaci\u00f3n y configuraci\u00f3n de webpack-dev-server\n\n\nCompilando desde ES6\n\n\nConfigurando Hot Module Replacement\n\n\nOnsenUI, React, babel-preset-react y react-hot-loader", 
            "title": "Inicio"
        }, 
        {
            "location": "/#hot-module-replacement-tutorial", 
            "text": "Peque\u00f1o tutorial sobre configuraci\u00f3n de Webpack, webpack-dev-server, ES6, React y Cordova   Creaci\u00f3n del bundle  Instalaci\u00f3n y configuraci\u00f3n de webpack-dev-server  Compilando desde ES6  Configurando Hot Module Replacement  OnsenUI, React, babel-preset-react y react-hot-loader", 
            "title": "Hot Module Replacement Tutorial"
        }, 
        {
            "location": "/bundle/", 
            "text": "Creaci\u00f3n del Bundle\n\n\nWebpack genera un archivo llamado bundle, donde almacenar\u00e1 las dependencias de nuestro proyecto a partir de los imports de este mismo. \n\n\nEn este tutorial usaremos \nyarn\n como gestor de paquetes, por lo que empezamos inicializando el proyecto creando el \npackage.json\n:\n\n\nyarn init\n\n\n\n\nSeguiremos con la instalaci\u00f3n de \nwebpack\n:\n\n\n$ yarn add webpack\n\n\n\n\nAhora configuraremos \nwebpack\n para la creaci\u00f3n de nuestro bundle. Crearemos el archivo \nwebpack.config.js\n y a\u00f1adiremos la siguiente configuraci\u00f3n:\n\n\nconst path = require('path');\n\nmodule.exports = {\n    context: path.resolve(__dirname),\n    devtool: \"eval-source-map\",\n    entry: {\n        main: './src/index.js'\n     },\n    output: {\n        path: path.resolve(__dirname, 'dist'),\n        filename: '[name].js',\n    }\n};\n\n\n\n\n\ncontext\n: ser\u00e1 el directorio base a partir del cual se se resuelven los puntos de entrada y los \nloaders\n\n\ndevtool\n: Controla como quieres que se generen los \nsource maps\n \nDocumentaci\u00f3n\n. Es importante controlar este valor ya que ser\u00e1 el que nos permita debugar la salida generada por \nwebpack\n\n\nentry\n: entrada desde la que se generar\u00e1 el \nbundle\n. Es el archivo de inicio de nuestra aplicaci\u00f3n, a partir del cual \nwebpack\nir\u00e1 construyendo el \nbundle\n \"tirando\" de las dependencias de los m\u00f3dulos que importamos.\n\n\noutput\n: controla donde y como queremos que se generen las salidas o salida de nuestro \nbundle\n y resto de archivos necesarios en nuestra aplicaci\u00f3n.\n\n\n\n\nCon la configuraci\u00f3n b\u00e1sica anterior, nos faltar\u00eda tener los archivos \nindex.js\n y sus dependencias. En el \nrepositorio\n preparado para este tutorial podr\u00e1s encontrar estos arhivos ya preparados.\n\n\nCrearemos una tarea de \nnpm\n que nos ejecute \nwebpack\n y nos genere nuestro \nbundle\n:\n\n\n\"build\": \"webpack\"\n\n\n\nSi ejecutamos este script:\n\n\n npm run build\n\n\n\nconstruiremos nuestro \nbundle\n que ser\u00e1 guardado en la ruta que hemos indicado en el \noutput\n:\n\n\n webpack\n\nHash: 019c0dd0b804295531e4\nVersion: webpack 2.6.1\nTime: 79ms\n  Asset     Size  Chunks             Chunk Names\nmain.js  4.49 kB       0  [emitted]  main\n   [0] ./src/App.js 149 bytes {0} [built]\n   [1] ./src/index.js 84 bytes {0} [built]", 
            "title": "Creaci\u00f3n del bundle"
        }, 
        {
            "location": "/bundle/#creacion-del-bundle", 
            "text": "Webpack genera un archivo llamado bundle, donde almacenar\u00e1 las dependencias de nuestro proyecto a partir de los imports de este mismo.   En este tutorial usaremos  yarn  como gestor de paquetes, por lo que empezamos inicializando el proyecto creando el  package.json :  yarn init  Seguiremos con la instalaci\u00f3n de  webpack :  $ yarn add webpack  Ahora configuraremos  webpack  para la creaci\u00f3n de nuestro bundle. Crearemos el archivo  webpack.config.js  y a\u00f1adiremos la siguiente configuraci\u00f3n:  const path = require('path');\n\nmodule.exports = {\n    context: path.resolve(__dirname),\n    devtool: \"eval-source-map\",\n    entry: {\n        main: './src/index.js'\n     },\n    output: {\n        path: path.resolve(__dirname, 'dist'),\n        filename: '[name].js',\n    }\n};   context : ser\u00e1 el directorio base a partir del cual se se resuelven los puntos de entrada y los  loaders  devtool : Controla como quieres que se generen los  source maps   Documentaci\u00f3n . Es importante controlar este valor ya que ser\u00e1 el que nos permita debugar la salida generada por  webpack  entry : entrada desde la que se generar\u00e1 el  bundle . Es el archivo de inicio de nuestra aplicaci\u00f3n, a partir del cual  webpack ir\u00e1 construyendo el  bundle  \"tirando\" de las dependencias de los m\u00f3dulos que importamos.  output : controla donde y como queremos que se generen las salidas o salida de nuestro  bundle  y resto de archivos necesarios en nuestra aplicaci\u00f3n.   Con la configuraci\u00f3n b\u00e1sica anterior, nos faltar\u00eda tener los archivos  index.js  y sus dependencias. En el  repositorio  preparado para este tutorial podr\u00e1s encontrar estos arhivos ya preparados.  Crearemos una tarea de  npm  que nos ejecute  webpack  y nos genere nuestro  bundle :  \"build\": \"webpack\"  Si ejecutamos este script:   npm run build  construiremos nuestro  bundle  que ser\u00e1 guardado en la ruta que hemos indicado en el  output :   webpack\n\nHash: 019c0dd0b804295531e4\nVersion: webpack 2.6.1\nTime: 79ms\n  Asset     Size  Chunks             Chunk Names\nmain.js  4.49 kB       0  [emitted]  main\n   [0] ./src/App.js 149 bytes {0} [built]\n   [1] ./src/index.js 84 bytes {0} [built]", 
            "title": "Creaci\u00f3n del Bundle"
        }, 
        {
            "location": "/webpackdevserver/", 
            "text": "Webpack-dev-server\n\n\nInstalamos \nwebpack-dev-server\n\n\nyarn add webpack-dev-server --dev\n\n\n\ny creamos una orden en los scripts del package.json para ejecutarlo:\n\n\n\u201cdev\u201d: \u201cwebpack-dev-server\u201d\n\n\n\nEste es un servidor de desarrollo que publicar\u00e1 los recursos de webpack para que sean accesibles desde el navegador. Lo que hace es crear un servidor de desarrollo que publica los recursos. Para ello configuramos en el webpack.config.js los siguientes cambios:\n\n\ndevServer: {\n    contentBase: path.join(__dirname, \"platforms/android/assets/www\"),\n    compress: true,\n    port: 3000,\n    publicPath: '/js/'  \n},\n\n\n\n\n\ncontentBase\n: carpeta desde la que se publicar\u00e1 la ra\u00edz de nuestro contenido\n\n\ncompress\n: comprime como gzip todo el contenido servido\n\n\nport\n: el puerto donde se publicar\u00e1 http://localhost:\n\n\npublicPath\n: el path donde ser\u00e1 publicados los recursos bundled, en nuestro caso que el valor es /js/ la ruta final de los archivos bundled ser\u00e1 http://localhost:\n/js/\n\n\n\n\nSi ejecutamos npm dev la salida nos dar\u00e1:\n\n\n   \n webpack-dev-server\n\n   Project is running at http://localhost:3000/\n   webpack output is served from /js/\n   Content not from webpack is served from /home/michogarcia/geomati.co/TMB/dev/hmr-tutorial/dist\n   Hash: b6f42794026ca8bf8d0a\n   Version: webpack 2.6.1\n   Time: 928ms\n     Asset    Size  Chunks                    Chunk Names\n   main.js  841 kB       0  [emitted]  [big]  main\n   chunk    {0} main.js (main) 302 kB [entry] [rendered]\n      [35] (webpack)-dev-server/client?http://localhost:3000 5.68 kB {0} [built]\n      [36] ./src/index.js 84 bytes {0} [built]\n      [37] ./~/ansi-html/index.js 4.26 kB {0} [built]\n      [38] ./~/ansi-regex/index.js 135 bytes {0} [built]\n      [40] ./~/events/events.js 8.33 kB {0} [built]\n      [41] ./~/html-entities/index.js 231 bytes {0} [built]\n      [48] ./~/querystring-es3/index.js 127 bytes {0} [built]\n      [77] ./~/strip-ansi/index.js 161 bytes {0} [built]\n      [78] ./~/url/url.js 23.3 kB {0} [built]\n      [79] ./~/url/util.js 314 bytes {0} [built]\n      [80] (webpack)-dev-server/client/overlay.js 3.73 kB {0} [built]\n      [81] (webpack)-dev-server/client/socket.js 897 bytes {0} [built]\n      [83] (webpack)/hot/emitter.js 77 bytes {0} [built]\n      [84] ./src/App.js 149 bytes {0} [built]\n      [85] multi (webpack)-dev-server/client?http://localhost:3000 ./src/index.js 40 bytes {0} [built]\n        + 71 hidden modules\n   webpack: Compiled successfully.\n\n\n\nwebpack-dev-server\n crear\u00e1 el \nbundle\n tal y como hemos definido y lo publicar\u00e1 en las rutas que hayamos configurado. Si nos \nfijamos en la salida, el propio servidor nos est\u00e1 indicando donde podemos encontrar nuestros \nbundles\n publicados:\n\n\nProject is running at http://localhost:3000/\n\n\n\nPodremos ver un resumen en:\n\n\nhttp://localhost:3000/webpack-dev-server\n\n\ny veremos nuestro \nbundle\n publicado en:\n\n\nhttp://localhost:3000/main.js\n\n\nPara comprobar como \nwebpack-dev-server\n nos ayuda en el desarrollo generando el \nbundle\n de manera din\u00e1mica cada vez que se detecta un cambio\ncrearemos un archivo \nindex.html\n en la carpeta \ndist\n que ser\u00e1 la carpeta que publicaremos.\n\n\nHaremos algunos cambios en la creaci\u00f3n del \nbundle\n para adaptarlo a la nueva estructura de carpetas. Para ello, modificaremos la salida:\n\n\noutput: {\n   path: path.resolve(__dirname, 'dist/js'),\n   filename: '[name].js',\n},\n\n\n\nindic\u00e1ndole la nueva ruta \ndist/js\n. Recordad que el raiz de nuestro \nwebpack-dev-server\n ser\u00e1 la propia carpeta \ndist\n y que el\n\npublicPath\n apunta a la que ser\u00e1 la carpeta \ndist/js\n donde se guardar\u00e1 el \nbundle\n que se genera.\n\n\nSi ejecutamos de nuevo:\n\n\nnpm run dev\n\n\n\npodremos observar que ahora la ruta de nuestro \nbundle\n (main.js) est\u00e1 en:\n\n\nhttp://localhost:3000/js/main.js\n\n\nSi vamos a la carpeta \ndist\n comprobaremos que no se ha creado ning\u00fan archivo en la misma, eso es porque en todo momento\n\nwebpack-dev-server\n est\u00e1 publicando el \nbundle\n desde memoria.\n\n\nAhora crearemos una \ndiv id=rootElement\n en el \nindex.html\n para poder visualizar como trabaja \nwebpack-dev-server\n.\n\n\nbody\n\n    \ndiv id=\"rootElement\"\n/div\n\n\n/body\n\n\n\n\nIncluiremos en nuestra \nApp.js\n la funcionalidad que modifique el contenido de esa \ndiv\n\n\nconstructor() {\n    document.getElementById('rootElement').innerHTML = '\nspan\nMira, \u00a1\u00a1funciona!!\n/span\n';\n}\n\n\n\ny haremos que el \nindex.html\n cargue nuestro \nbundle\n.\n\n\nscript type=\"text/javascript\" src=\"./js/main.js\"\n/script\n\n\n\n\nSi modificamos nuestra \nApp.js\n por ejemplo cambiando el texto, veremos como \nwebpack-dev-server\n \"compila\" de nuevo\n\n\n webpack: Compiling...\n Hash: e5d45663418c4a61284b\n Version: webpack 2.6.1\n Time: 146ms\n   Asset    Size  Chunks                    Chunk Names\n main.js  841 kB       0  [emitted]  [big]  main\n chunk    {0} main.js (main) 302 kB [entry] [rendered]\n    [84] ./src/App.js 201 bytes {0} [built]\n      + 85 hidden modules\n webpack: Compiled successfully.\n\n\n\ny publica el nuevo \nbundle\n aplicando los cambios autom\u00e1ticamente sin refrescar.", 
            "title": "Instalaci\u00f3n y configuraci\u00f3n de webpack-dev-server"
        }, 
        {
            "location": "/webpackdevserver/#webpack-dev-server", 
            "text": "Instalamos  webpack-dev-server  yarn add webpack-dev-server --dev  y creamos una orden en los scripts del package.json para ejecutarlo:  \u201cdev\u201d: \u201cwebpack-dev-server\u201d  Este es un servidor de desarrollo que publicar\u00e1 los recursos de webpack para que sean accesibles desde el navegador. Lo que hace es crear un servidor de desarrollo que publica los recursos. Para ello configuramos en el webpack.config.js los siguientes cambios:  devServer: {\n    contentBase: path.join(__dirname, \"platforms/android/assets/www\"),\n    compress: true,\n    port: 3000,\n    publicPath: '/js/'  \n},   contentBase : carpeta desde la que se publicar\u00e1 la ra\u00edz de nuestro contenido  compress : comprime como gzip todo el contenido servido  port : el puerto donde se publicar\u00e1 http://localhost:  publicPath : el path donde ser\u00e1 publicados los recursos bundled, en nuestro caso que el valor es /js/ la ruta final de los archivos bundled ser\u00e1 http://localhost: /js/   Si ejecutamos npm dev la salida nos dar\u00e1:       webpack-dev-server\n\n   Project is running at http://localhost:3000/\n   webpack output is served from /js/\n   Content not from webpack is served from /home/michogarcia/geomati.co/TMB/dev/hmr-tutorial/dist\n   Hash: b6f42794026ca8bf8d0a\n   Version: webpack 2.6.1\n   Time: 928ms\n     Asset    Size  Chunks                    Chunk Names\n   main.js  841 kB       0  [emitted]  [big]  main\n   chunk    {0} main.js (main) 302 kB [entry] [rendered]\n      [35] (webpack)-dev-server/client?http://localhost:3000 5.68 kB {0} [built]\n      [36] ./src/index.js 84 bytes {0} [built]\n      [37] ./~/ansi-html/index.js 4.26 kB {0} [built]\n      [38] ./~/ansi-regex/index.js 135 bytes {0} [built]\n      [40] ./~/events/events.js 8.33 kB {0} [built]\n      [41] ./~/html-entities/index.js 231 bytes {0} [built]\n      [48] ./~/querystring-es3/index.js 127 bytes {0} [built]\n      [77] ./~/strip-ansi/index.js 161 bytes {0} [built]\n      [78] ./~/url/url.js 23.3 kB {0} [built]\n      [79] ./~/url/util.js 314 bytes {0} [built]\n      [80] (webpack)-dev-server/client/overlay.js 3.73 kB {0} [built]\n      [81] (webpack)-dev-server/client/socket.js 897 bytes {0} [built]\n      [83] (webpack)/hot/emitter.js 77 bytes {0} [built]\n      [84] ./src/App.js 149 bytes {0} [built]\n      [85] multi (webpack)-dev-server/client?http://localhost:3000 ./src/index.js 40 bytes {0} [built]\n        + 71 hidden modules\n   webpack: Compiled successfully.  webpack-dev-server  crear\u00e1 el  bundle  tal y como hemos definido y lo publicar\u00e1 en las rutas que hayamos configurado. Si nos \nfijamos en la salida, el propio servidor nos est\u00e1 indicando donde podemos encontrar nuestros  bundles  publicados:  Project is running at http://localhost:3000/  Podremos ver un resumen en:  http://localhost:3000/webpack-dev-server  y veremos nuestro  bundle  publicado en:  http://localhost:3000/main.js  Para comprobar como  webpack-dev-server  nos ayuda en el desarrollo generando el  bundle  de manera din\u00e1mica cada vez que se detecta un cambio\ncrearemos un archivo  index.html  en la carpeta  dist  que ser\u00e1 la carpeta que publicaremos.  Haremos algunos cambios en la creaci\u00f3n del  bundle  para adaptarlo a la nueva estructura de carpetas. Para ello, modificaremos la salida:  output: {\n   path: path.resolve(__dirname, 'dist/js'),\n   filename: '[name].js',\n},  indic\u00e1ndole la nueva ruta  dist/js . Recordad que el raiz de nuestro  webpack-dev-server  ser\u00e1 la propia carpeta  dist  y que el publicPath  apunta a la que ser\u00e1 la carpeta  dist/js  donde se guardar\u00e1 el  bundle  que se genera.  Si ejecutamos de nuevo:  npm run dev  podremos observar que ahora la ruta de nuestro  bundle  (main.js) est\u00e1 en:  http://localhost:3000/js/main.js  Si vamos a la carpeta  dist  comprobaremos que no se ha creado ning\u00fan archivo en la misma, eso es porque en todo momento webpack-dev-server  est\u00e1 publicando el  bundle  desde memoria.  Ahora crearemos una  div id=rootElement  en el  index.html  para poder visualizar como trabaja  webpack-dev-server .  body \n     div id=\"rootElement\" /div  /body   Incluiremos en nuestra  App.js  la funcionalidad que modifique el contenido de esa  div  constructor() {\n    document.getElementById('rootElement').innerHTML = ' span Mira, \u00a1\u00a1funciona!! /span ';\n}  y haremos que el  index.html  cargue nuestro  bundle .  script type=\"text/javascript\" src=\"./js/main.js\" /script   Si modificamos nuestra  App.js  por ejemplo cambiando el texto, veremos como  webpack-dev-server  \"compila\" de nuevo   webpack: Compiling...\n Hash: e5d45663418c4a61284b\n Version: webpack 2.6.1\n Time: 146ms\n   Asset    Size  Chunks                    Chunk Names\n main.js  841 kB       0  [emitted]  [big]  main\n chunk    {0} main.js (main) 302 kB [entry] [rendered]\n    [84] ./src/App.js 201 bytes {0} [built]\n      + 85 hidden modules\n webpack: Compiled successfully.  y publica el nuevo  bundle  aplicando los cambios autom\u00e1ticamente sin refrescar.", 
            "title": "Webpack-dev-server"
        }, 
        {
            "location": "/babel/", 
            "text": "Compilando desde ES6\n\n\nComo ya os habr\u00e9is fijado, hemos escrito nuestro c\u00f3digo usando ES6. Aunque cada vez m\u00e1s los navegadores incorporan pr\u00e1cticamente \n todas las funcionalidades del nuevo estandar, pero en algunso casos querremos compilar nuestro c\u00f3digo desde ES6 a ES5. \n\n\nPara ello utilizaremos \nBabel\n un compilador de JavaScript que nos permite realizar esta compilaci\u00f3n.\n\n\nTendremos instalar algunos paquetes y realizar algunos cambios en la configuraci\u00f3n del \nwebpack\n.\n\n\nPara realizar la compilaci\u00f3n usaremos los \nloaders\n de \nwebpack\n. Los loaders se encargan de realizar ciertas operaciones \n durante la creaci\u00f3n del \nbundle\n.\n\n\nPrimero instalamos los paquetes necesarios para la compilaci\u00f3n:\n\n\nyarn add babel-core babel-loader --dev\n\n\n\ny a\u00f1adimos la configuraci\u00f3n necesaria:\n\n\n module: {\n     rules: [\n         {\n             test: /\\.(js|jsx)$/,\n             exclude: [/node_modules/],\n             use: ['babel-loader'],\n         }\n     ],\n },\n\n\n\n\n\nmodule\n: se encarga de definir los t\u00edpos de m\u00f3dulos que tenemos dentro del proyecto y nos permite configurar diferentes\n tratamientos.\n\n\nrules\n: reglas que aplicar\u00e1n configuraciones sobre aquellos m\u00f3dulos que las cumplan. Se trata de un \nArray\n en el que se van incluyendo\n las diferentes reglas\n\n\n\n\nUna \nrule\n viene definida por un objeto que a su vez tiene unas propiedades, en nuestro caso:\n\n\n\n\ntest\n: la regla que se aplicar\u00e1 a los recursos, en nuestro caso es una expresi\u00f3n regular que aplica la configuraci\u00f3n \n definida a los archivos con extensi\u00f3n \n.js\n o \n.jsx\n. \nDocumentaci\u00f3n Oficial\n\n\nexclude\n: \nNO\n se aplica a los recursos que cumplan la condici\u00f3n, en nuestro caso que se encuentren en el path \nnode_modules\n\n evitando as\u00ed la compilaci\u00f3n de los archivos que se encuentran en esa carpeta\n\n\nuse\n: listado de \nloaders\n que ser\u00e1n aplicados a los recursos\n\n\n\n\nAhora nuestro c\u00f3digo estar\u00e1 preparado para los navegadores que no implementen todav\u00eda ES6.", 
            "title": "Compilando desde ES6"
        }, 
        {
            "location": "/babel/#compilando-desde-es6", 
            "text": "Como ya os habr\u00e9is fijado, hemos escrito nuestro c\u00f3digo usando ES6. Aunque cada vez m\u00e1s los navegadores incorporan pr\u00e1cticamente \n todas las funcionalidades del nuevo estandar, pero en algunso casos querremos compilar nuestro c\u00f3digo desde ES6 a ES5.   Para ello utilizaremos  Babel  un compilador de JavaScript que nos permite realizar esta compilaci\u00f3n.  Tendremos instalar algunos paquetes y realizar algunos cambios en la configuraci\u00f3n del  webpack .  Para realizar la compilaci\u00f3n usaremos los  loaders  de  webpack . Los loaders se encargan de realizar ciertas operaciones \n durante la creaci\u00f3n del  bundle .  Primero instalamos los paquetes necesarios para la compilaci\u00f3n:  yarn add babel-core babel-loader --dev  y a\u00f1adimos la configuraci\u00f3n necesaria:   module: {\n     rules: [\n         {\n             test: /\\.(js|jsx)$/,\n             exclude: [/node_modules/],\n             use: ['babel-loader'],\n         }\n     ],\n },   module : se encarga de definir los t\u00edpos de m\u00f3dulos que tenemos dentro del proyecto y nos permite configurar diferentes\n tratamientos.  rules : reglas que aplicar\u00e1n configuraciones sobre aquellos m\u00f3dulos que las cumplan. Se trata de un  Array  en el que se van incluyendo\n las diferentes reglas   Una  rule  viene definida por un objeto que a su vez tiene unas propiedades, en nuestro caso:   test : la regla que se aplicar\u00e1 a los recursos, en nuestro caso es una expresi\u00f3n regular que aplica la configuraci\u00f3n \n definida a los archivos con extensi\u00f3n  .js  o  .jsx .  Documentaci\u00f3n Oficial  exclude :  NO  se aplica a los recursos que cumplan la condici\u00f3n, en nuestro caso que se encuentren en el path  node_modules \n evitando as\u00ed la compilaci\u00f3n de los archivos que se encuentran en esa carpeta  use : listado de  loaders  que ser\u00e1n aplicados a los recursos   Ahora nuestro c\u00f3digo estar\u00e1 preparado para los navegadores que no implementen todav\u00eda ES6.", 
            "title": "Compilando desde ES6"
        }, 
        {
            "location": "/hrm/", 
            "text": "Configurando Hot Module Replacement\n\n\nHot Module Replacement\n, HMR, permite intercambiar, a\u00f1adir o eliminar m\u00f3dulos sin necesidad de hacer una recarga completa de\nla aplicaci\u00f3n.\n\n\nComenzaremos configurando HMR modificando el \nwebpack.config.js\n para incluir estos cambios.\n\n\nIncluiremos el \nplugin\n de HMR:\n\n\nplugins: [\n    new webpack.HotModuleReplacementPlugin() // Enable HMR\n  ],\n\n\n\nlos plugins permiten modificar el comportamiento de \nwebpack\n a\u00f1adiendole nuevas funcionalidades.\n\n\nAhora le diremos al \nwebpack-dev-server\n que utilice HMR:\n\n\ndevServer: {\n    contentBase: path.join(__dirname, \"dist\"),\n    hot: true, // Tell the dev-server we're using HMR\n    compress: true,\n    port: 3000,\n    publicPath: '/js/'\n},\n\n\n\nA\u00f1adiremos la propiedad \npublicPath\n tambi\u00e9n al \noutput\n:\n\n\noutput: {\n    path: path.resolve(__dirname, 'dist/js'),\n    filename: '[name].js',\n    publicPath: \"/js/\"\n},\n\n\n\nComo se \nexplica en la documentaci\u00f3n\n hemos de indicar \nen nuestros m\u00f3dulos que hagan uso de HMR. Esto lo podemos hacer a nivel de m\u00f3dulo o directamente en el m\u00f3dulo\nraiz que har\u00e1 que HMR lo use todo el arbol de m\u00f3dulos. Para ello a\u00f1adiremos a nuestro archivo \nindex.js\n el c\u00f3digo necesario para \nhacer uso de HMR:\n\n\nif (module.hot) {\n    module.hot.accept();\n}\n\n\n\nSi ahora realizamos un cambio en \nApp.js\n veremos que se aplican estos sin recargar toda la p\u00e1gina. Podremos ver la salida \nen la consola de desarrollo:\n\n\n\n\nComo podemos observar, los nombres de los archivos que han cambiado no aparecen. Para evitar esto, a\u00f1adiremos un plugin a la \nconfiguraci\u00f3n actual de \nwebpack\n\n\nplugins: [\n    new webpack.HotModuleReplacementPlugin(), // Enable HMR\n    new webpack.NamedModulesPlugin(),\n],\n\n\n\n\n\nReferencias\n\n\nWebpack \n The Hot Module Replacement", 
            "title": "Configurando Hot Module Replacement"
        }, 
        {
            "location": "/hrm/#configurando-hot-module-replacement", 
            "text": "Hot Module Replacement , HMR, permite intercambiar, a\u00f1adir o eliminar m\u00f3dulos sin necesidad de hacer una recarga completa de\nla aplicaci\u00f3n.  Comenzaremos configurando HMR modificando el  webpack.config.js  para incluir estos cambios.  Incluiremos el  plugin  de HMR:  plugins: [\n    new webpack.HotModuleReplacementPlugin() // Enable HMR\n  ],  los plugins permiten modificar el comportamiento de  webpack  a\u00f1adiendole nuevas funcionalidades.  Ahora le diremos al  webpack-dev-server  que utilice HMR:  devServer: {\n    contentBase: path.join(__dirname, \"dist\"),\n    hot: true, // Tell the dev-server we're using HMR\n    compress: true,\n    port: 3000,\n    publicPath: '/js/'\n},  A\u00f1adiremos la propiedad  publicPath  tambi\u00e9n al  output :  output: {\n    path: path.resolve(__dirname, 'dist/js'),\n    filename: '[name].js',\n    publicPath: \"/js/\"\n},  Como se  explica en la documentaci\u00f3n  hemos de indicar \nen nuestros m\u00f3dulos que hagan uso de HMR. Esto lo podemos hacer a nivel de m\u00f3dulo o directamente en el m\u00f3dulo\nraiz que har\u00e1 que HMR lo use todo el arbol de m\u00f3dulos. Para ello a\u00f1adiremos a nuestro archivo  index.js  el c\u00f3digo necesario para \nhacer uso de HMR:  if (module.hot) {\n    module.hot.accept();\n}  Si ahora realizamos un cambio en  App.js  veremos que se aplican estos sin recargar toda la p\u00e1gina. Podremos ver la salida \nen la consola de desarrollo:   Como podemos observar, los nombres de los archivos que han cambiado no aparecen. Para evitar esto, a\u00f1adiremos un plugin a la \nconfiguraci\u00f3n actual de  webpack  plugins: [\n    new webpack.HotModuleReplacementPlugin(), // Enable HMR\n    new webpack.NamedModulesPlugin(),\n],", 
            "title": "Configurando Hot Module Replacement"
        }, 
        {
            "location": "/hrm/#referencias", 
            "text": "Webpack   The Hot Module Replacement", 
            "title": "Referencias"
        }, 
        {
            "location": "/react/", 
            "text": "OnsenUI, React, babel-preset-react y react-hot-loader\n\n\nEl objetivo de este tutorial es configurar un stack de herramientas para desarrollar aplicaciones m\u00f3vil h\u00edbridas, \ny para ello utilizaremos el framework \nOnsenUI con React\n. Este framework dispone de herramientas\nde construcci\u00f3n del proyecto, \nMonaca\n pero realizaremos nuestra propia configuraci\u00f3n para poder\ntener control sobre el entorno de desarrollo y comprender todos los pasos de la configuraci\u00f3n de nuestro propio \nwebpack\n.\n\n\nOnsenUI\n\n\nLo primero que haremos ser\u00e1 instalar y configurar nuestra plantilla b\u00e1sica con Onsen.\n\n\nyarn add onsenui react-onsenui react react-dom\n\n\n\nas\u00ed tendremos todas las librer\u00edas necesarias para seguir adelante. Ahora modificaremos el nuestra aplicaci\u00f3n para que utilice \neste framework. Para ello crearemos una \nApp.js\n de OnsenUI:\n\n\nimport React, { Component } from 'react';\nimport { Page, Button } from 'react-onsenui'\n\nclass App extends Component {\n\n    render() {\n        return (\n            \nPage\n\n                \nButton onClick={this.handleClick}\nTap me!\n/Button\n\n            \n/Page\n\n        );\n    };\n}\n\nexport default App;\n\n\n\ny modificaremos nuestro \nindex.js\n para utilizar nuestra nueva \nApp.js\n:\n\n\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\nconst rootElement = document.getElementById('app');\n\nconst render = Component =\n\n    ReactDOM.render(\n        \nAppContainer\n\n            \nComponent /\n\n        \n/AppContainer\n,\n        rootElement\n    );\n\nrender(App);\n\nif (module.hot) {\n    module.hot.accept('./App', () =\n render(App));\n}\n\n\n\nAl arrancar nuestro \nwebpack-dev-server\n obtendremos un error:\n\n\n webpack-dev-server --host 0.0.0.0\n\nProject is running at http://0.0.0.0:3000/\nwebpack output is served from /js/\nContent not from webpack is served from /home/michogarcia/geomati.co/TMB/dev/cordova-hmr-react-tutorial/dist\nHash: c0697a3b40373c8d8f34\nVersion: webpack 2.6.1\nTime: 1127ms\n  Asset    Size  Chunks                    Chunk Names\nmain.js  901 kB       0  [emitted]  [big]  main\nchunk    {0} main.js (main) 305 kB [entry] [rendered]\n [./node_modules/ansi-regex/index.js] ./~/ansi-regex/index.js 135 bytes {0} [built]\n [./node_modules/events/events.js] ./~/events/events.js 8.33 kB {0} [built]\n [./node_modules/html-entities/index.js] ./~/html-entities/index.js 231 bytes {0} [built]\n [./node_modules/punycode/punycode.js] ./~/punycode/punycode.js 14.7 kB {0} [built]\n [./node_modules/strip-ansi/index.js] ./~/strip-ansi/index.js 161 bytes {0} [built]\n [./node_modules/url/url.js] ./~/url/url.js 23.3 kB {0} [built]\n [./node_modules/url/util.js] ./~/url/util.js 314 bytes {0} [built]\n [./node_modules/webpack-dev-server/client/index.js?http:/0.0.0.0:3000] (webpack)-dev-server/client?http://0.0.0.0:3000 5.68 kB {0} [built]\n [./node_modules/webpack-dev-server/client/overlay.js] (webpack)-dev-server/client/overlay.js 3.73 kB {0} [built]\n [./node_modules/webpack-dev-server/client/socket.js] (webpack)-dev-server/client/socket.js 897 bytes {0} [built]\n [./node_modules/webpack/hot/dev-server.js] (webpack)/hot/dev-server.js 1.57 kB {0} [built]\n [./node_modules/webpack/hot/emitter.js] (webpack)/hot/emitter.js 77 bytes {0} [built]\n    [0] multi (webpack)-dev-server/client?http://0.0.0.0:3000 webpack/hot/dev-server ./src/index.js 52 bytes {0} [built]\n [./node_modules/webpack/hot/log-apply-result.js] (webpack)/hot/log-apply-result.js 1.02 kB {0} [built]\n [./src/index.js] ./src/index.js 732 bytes {0} [built] [failed] [1 error]\n     + 72 hidden modules\n\nERROR in ./src/index.js\nModule build failed: SyntaxError: Unexpected token (13:12)\n\n  11 | const render = Component =\n\n  12 |     ReactDOM.render(\n\n 13 |             \nComponent /\n,\n     |             ^\n  14 |         rootElement\n  15 |     );\n  16 |\n\n @ multi (webpack)-dev-server/client?http://0.0.0.0:3000 webpack/hot/dev-server ./src/index.js\nwebpack: Failed to compile.\n\n\n\nbabel-preset-react\n\n\nEsto es debido a que \nwebpack\n no es capaz de compilar nuestra s\u00edntaxis de React. Para ello deberemos configurar un preset de Babel\n que sea capaz de compilar dicha s\u00edntaxis. \nbabel-preset-react\n ser\u00e1 el encargado de dicha tarea. \n Primero la instalamos, y aprovechando, instalaremos el preset de \nbabel\n para ES2015 que nos dar\u00e1 acceso a todos los plugins de ES6:\n\n\nyarn add babel-preset-react babel-preset-es2015 --dev\n\n\n\nY configuramos \nbabel\n para que use este preset. Crearemos un archivo \n.babelrc\n en el raiz de nuestro directorio y a\u00f1adiremos:\n\n\n {\n   \"presets\": [\n     [\"es2015\", {\"modules\": false}],\n     \"react\"\n   ]\n }\n\n\n\nAhora nuestra aplicaci\u00f3n lucir\u00e1 de la siguiente manera:\n\n\n\n\n\u00bfQu\u00e9 pasa con los estilos?, \u00bfporqu\u00e9 no aparecen los botones?. Para ello deberemos cargar los CSS de OnsenUI que se encarga \n de dar forma a los componentes.\n\n\nPara ello importaremos estos estilos desde nuestro \nindes.js\n:\n\n\n require('onsenui/css/onsen-css-components.css');\n require('onsenui/css/onsenui.css');\n\n\n\nY de nuevo obtendremos un error:\n\n\n ERROR in ./~/onsenui/css/onsenui.css\n Module parse failed: /home/michogarcia/geomati.co/TMB/dev/cordova-hmr-react-tutorial/node_modules/onsenui/css/onsenui.css Unexpected character '@' (19:0)\n You may need an appropriate loader to handle this file type.\n |  */\n | \n | @import url(\"ionicons/css/ionicons.min.css\");\n | @import url(\"material-design-iconic-font/css/material-design-iconic-font.min.css\");\n | @import url(\"font_awesome/css/font-awesome.min.css\");\n  @ ./src/index.js 10:0-34\n  @ multi (webpack)-dev-server/client?http://0.0.0.0:3000 webpack/hot/dev-server ./src/index.js\n\n\n\nEsto es similar a lo sucedido con React, y es que tendremos que decirle a \nwebpack\n el tipo de m\u00f3dulos que estamos intentando\n cargar. Para ello instalaremos los \nloaders\n necesarios:\n\n\nyarn add css-loader style-loader file-loader --dev\n\n\n\ny modificamos la configuraci\u00f3n de nuestro \nwebpack.config.js\n para que use estos loaders:\n\n\n    module: {\n        rules: [\n            {\n                test: /\\.(js|jsx)$/,\n                exclude: [/node_modules/],\n                use: ['babel-loader'],\n            },\n            {\n                test: /\\.css$/,\n                use: [ 'style-loader', 'css-loader' ]\n            },\n            {\n                test: /\\.(ttf|otf|eot|svg|woff(2)?)(\\?[a-z0-9]+)?$/,\n                loader: 'file-loader?name=assets/[name].[ext]'\n            }\n        ],\n    },\n\n\n\n\n\nreact-hot-loader\n\n\nPara probar \nreact-hot-loader\n haremos unas peque\u00f1as modificaciones en nuestra \nApp.js\n. A\u00f1adiremos un estado a nuestro \ncomponente para poder probar la funcionalidad que aporta \nreact-hot-loader\n, ya que lo que consigue es mantener el estado \nde nuestro componente a pesar de actualizar el m\u00f3dulo.\n\n\nComo se puede observar en el c\u00f3digo, hemos a\u00f1adido un estado \nsum\n en el constructor del componente:\n\n\nconstructor(props) {\n    super(props)\n    this.state = {\n        sum: 0\n    }\n}\n\n\n\nA\u00f1adiremos el evento que se encargue de modificar el estado, en este caso un evento disparado desde el bot\u00f3n:\n\n\nhandleClick() {\n    this.setState({\n        sum: this.state.sum += 2\n    })\n}\n\n\n\ny lo enlazamos al bot\u00f3n:\n\n\nrender() {\n    return (\n        \nPage\n\n            \nButton onClick={this.handleClick.bind(this)}\nSuma = {this.state.sum}\n/Button\n\n        \n/Page\n\n    );\n};\n\n\n\nAhora cada vez que pulsemos el bot\u00f3n modificar\u00e1 el texto del mismo:\n\n\n\n\nPero si tras haber pulsado y modificado el estado, cambiamos el texto del bot\u00f3n, HMR recargar\u00e1 nuestro bot\u00f3n y reiniciar\u00e1 \nel estado del componente cambiando el valor a su estado inicial.\n\n\n\n\nAhora es cuando entra en juego \nreact-hot-loader\n, ya que este permitir\u00e1 mantener el estado de nuestro componente tras la \nrecarga del c\u00f3digo mediante HMR.\n\n\nEmpezaremos instalando \nreact-hot-loader\n:\n\n\nyarn add react-hot-loader@next --dev\n\n\n\nmodificaremos el \nwebpack.config.js\n para activarlo:\n\n\nentry: [\n    'react-hot-loader/patch',\n    // activate HMR for React\n\n    './src/index.js',\n    // the entry point of our app\n]\n\n\n\nPor \u00faltimo debemos modificar nuestro punto de entrada para que utilice el \nAppContainer\n de \nreact-hot-loader\n que ser\u00e1\nel encargado de mantener el estado de nuestra aplicaci\u00f3n. El componente ra\u00edz de la aplicaci\u00f3n deber\u00e1 estar contenido dentro\ndel componente \nAppContainer\n:\n\n\nconst render = Component =\n {\n    ReactDOM.render(\n        \nAppContainer\n\n            \nComponent /\n\n        \n/AppContainer\n,\n        rootElement\n    )\n}\n\nrender(App)\n\nif (module.hot) {\n    module.hot.accept('./App', () =\n { render(App) })\n}\n\n\n\nDe esta manera si realizamos el proceso anterior, modificando el estado de nuestro componente y a su vez modificamos el c\u00f3digo\npara que actue HMR, veremos como el estado del componente se mantiene tras la actualizaci\u00f3n.\n\n\nReferencias\n\n\nhttps://thesabbir.com/hot-reloading-react-stateless-components/", 
            "title": "OnsenUI, React, babel-preset-react y react-hot-loader"
        }, 
        {
            "location": "/react/#onsenui-react-babel-preset-react-y-react-hot-loader", 
            "text": "El objetivo de este tutorial es configurar un stack de herramientas para desarrollar aplicaciones m\u00f3vil h\u00edbridas, \ny para ello utilizaremos el framework  OnsenUI con React . Este framework dispone de herramientas\nde construcci\u00f3n del proyecto,  Monaca  pero realizaremos nuestra propia configuraci\u00f3n para poder\ntener control sobre el entorno de desarrollo y comprender todos los pasos de la configuraci\u00f3n de nuestro propio  webpack .", 
            "title": "OnsenUI, React, babel-preset-react y react-hot-loader"
        }, 
        {
            "location": "/react/#onsenui", 
            "text": "Lo primero que haremos ser\u00e1 instalar y configurar nuestra plantilla b\u00e1sica con Onsen.  yarn add onsenui react-onsenui react react-dom  as\u00ed tendremos todas las librer\u00edas necesarias para seguir adelante. Ahora modificaremos el nuestra aplicaci\u00f3n para que utilice \neste framework. Para ello crearemos una  App.js  de OnsenUI:  import React, { Component } from 'react';\nimport { Page, Button } from 'react-onsenui'\n\nclass App extends Component {\n\n    render() {\n        return (\n             Page \n                 Button onClick={this.handleClick} Tap me! /Button \n             /Page \n        );\n    };\n}\n\nexport default App;  y modificaremos nuestro  index.js  para utilizar nuestra nueva  App.js :  import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\nconst rootElement = document.getElementById('app');\n\nconst render = Component = \n    ReactDOM.render(\n         AppContainer \n             Component / \n         /AppContainer ,\n        rootElement\n    );\n\nrender(App);\n\nif (module.hot) {\n    module.hot.accept('./App', () =  render(App));\n}  Al arrancar nuestro  webpack-dev-server  obtendremos un error:   webpack-dev-server --host 0.0.0.0\n\nProject is running at http://0.0.0.0:3000/\nwebpack output is served from /js/\nContent not from webpack is served from /home/michogarcia/geomati.co/TMB/dev/cordova-hmr-react-tutorial/dist\nHash: c0697a3b40373c8d8f34\nVersion: webpack 2.6.1\nTime: 1127ms\n  Asset    Size  Chunks                    Chunk Names\nmain.js  901 kB       0  [emitted]  [big]  main\nchunk    {0} main.js (main) 305 kB [entry] [rendered]\n [./node_modules/ansi-regex/index.js] ./~/ansi-regex/index.js 135 bytes {0} [built]\n [./node_modules/events/events.js] ./~/events/events.js 8.33 kB {0} [built]\n [./node_modules/html-entities/index.js] ./~/html-entities/index.js 231 bytes {0} [built]\n [./node_modules/punycode/punycode.js] ./~/punycode/punycode.js 14.7 kB {0} [built]\n [./node_modules/strip-ansi/index.js] ./~/strip-ansi/index.js 161 bytes {0} [built]\n [./node_modules/url/url.js] ./~/url/url.js 23.3 kB {0} [built]\n [./node_modules/url/util.js] ./~/url/util.js 314 bytes {0} [built]\n [./node_modules/webpack-dev-server/client/index.js?http:/0.0.0.0:3000] (webpack)-dev-server/client?http://0.0.0.0:3000 5.68 kB {0} [built]\n [./node_modules/webpack-dev-server/client/overlay.js] (webpack)-dev-server/client/overlay.js 3.73 kB {0} [built]\n [./node_modules/webpack-dev-server/client/socket.js] (webpack)-dev-server/client/socket.js 897 bytes {0} [built]\n [./node_modules/webpack/hot/dev-server.js] (webpack)/hot/dev-server.js 1.57 kB {0} [built]\n [./node_modules/webpack/hot/emitter.js] (webpack)/hot/emitter.js 77 bytes {0} [built]\n    [0] multi (webpack)-dev-server/client?http://0.0.0.0:3000 webpack/hot/dev-server ./src/index.js 52 bytes {0} [built]\n [./node_modules/webpack/hot/log-apply-result.js] (webpack)/hot/log-apply-result.js 1.02 kB {0} [built]\n [./src/index.js] ./src/index.js 732 bytes {0} [built] [failed] [1 error]\n     + 72 hidden modules\n\nERROR in ./src/index.js\nModule build failed: SyntaxError: Unexpected token (13:12)\n\n  11 | const render = Component = \n  12 |     ReactDOM.render(  13 |              Component / ,\n     |             ^\n  14 |         rootElement\n  15 |     );\n  16 |\n\n @ multi (webpack)-dev-server/client?http://0.0.0.0:3000 webpack/hot/dev-server ./src/index.js\nwebpack: Failed to compile.", 
            "title": "OnsenUI"
        }, 
        {
            "location": "/react/#babel-preset-react", 
            "text": "Esto es debido a que  webpack  no es capaz de compilar nuestra s\u00edntaxis de React. Para ello deberemos configurar un preset de Babel\n que sea capaz de compilar dicha s\u00edntaxis.  babel-preset-react  ser\u00e1 el encargado de dicha tarea. \n Primero la instalamos, y aprovechando, instalaremos el preset de  babel  para ES2015 que nos dar\u00e1 acceso a todos los plugins de ES6:  yarn add babel-preset-react babel-preset-es2015 --dev  Y configuramos  babel  para que use este preset. Crearemos un archivo  .babelrc  en el raiz de nuestro directorio y a\u00f1adiremos:   {\n   \"presets\": [\n     [\"es2015\", {\"modules\": false}],\n     \"react\"\n   ]\n }  Ahora nuestra aplicaci\u00f3n lucir\u00e1 de la siguiente manera:   \u00bfQu\u00e9 pasa con los estilos?, \u00bfporqu\u00e9 no aparecen los botones?. Para ello deberemos cargar los CSS de OnsenUI que se encarga \n de dar forma a los componentes.  Para ello importaremos estos estilos desde nuestro  indes.js :   require('onsenui/css/onsen-css-components.css');\n require('onsenui/css/onsenui.css');  Y de nuevo obtendremos un error:   ERROR in ./~/onsenui/css/onsenui.css\n Module parse failed: /home/michogarcia/geomati.co/TMB/dev/cordova-hmr-react-tutorial/node_modules/onsenui/css/onsenui.css Unexpected character '@' (19:0)\n You may need an appropriate loader to handle this file type.\n |  */\n | \n | @import url(\"ionicons/css/ionicons.min.css\");\n | @import url(\"material-design-iconic-font/css/material-design-iconic-font.min.css\");\n | @import url(\"font_awesome/css/font-awesome.min.css\");\n  @ ./src/index.js 10:0-34\n  @ multi (webpack)-dev-server/client?http://0.0.0.0:3000 webpack/hot/dev-server ./src/index.js  Esto es similar a lo sucedido con React, y es que tendremos que decirle a  webpack  el tipo de m\u00f3dulos que estamos intentando\n cargar. Para ello instalaremos los  loaders  necesarios:  yarn add css-loader style-loader file-loader --dev  y modificamos la configuraci\u00f3n de nuestro  webpack.config.js  para que use estos loaders:      module: {\n        rules: [\n            {\n                test: /\\.(js|jsx)$/,\n                exclude: [/node_modules/],\n                use: ['babel-loader'],\n            },\n            {\n                test: /\\.css$/,\n                use: [ 'style-loader', 'css-loader' ]\n            },\n            {\n                test: /\\.(ttf|otf|eot|svg|woff(2)?)(\\?[a-z0-9]+)?$/,\n                loader: 'file-loader?name=assets/[name].[ext]'\n            }\n        ],\n    },", 
            "title": "babel-preset-react"
        }, 
        {
            "location": "/react/#react-hot-loader", 
            "text": "Para probar  react-hot-loader  haremos unas peque\u00f1as modificaciones en nuestra  App.js . A\u00f1adiremos un estado a nuestro \ncomponente para poder probar la funcionalidad que aporta  react-hot-loader , ya que lo que consigue es mantener el estado \nde nuestro componente a pesar de actualizar el m\u00f3dulo.  Como se puede observar en el c\u00f3digo, hemos a\u00f1adido un estado  sum  en el constructor del componente:  constructor(props) {\n    super(props)\n    this.state = {\n        sum: 0\n    }\n}  A\u00f1adiremos el evento que se encargue de modificar el estado, en este caso un evento disparado desde el bot\u00f3n:  handleClick() {\n    this.setState({\n        sum: this.state.sum += 2\n    })\n}  y lo enlazamos al bot\u00f3n:  render() {\n    return (\n         Page \n             Button onClick={this.handleClick.bind(this)} Suma = {this.state.sum} /Button \n         /Page \n    );\n};  Ahora cada vez que pulsemos el bot\u00f3n modificar\u00e1 el texto del mismo:   Pero si tras haber pulsado y modificado el estado, cambiamos el texto del bot\u00f3n, HMR recargar\u00e1 nuestro bot\u00f3n y reiniciar\u00e1 \nel estado del componente cambiando el valor a su estado inicial.   Ahora es cuando entra en juego  react-hot-loader , ya que este permitir\u00e1 mantener el estado de nuestro componente tras la \nrecarga del c\u00f3digo mediante HMR.  Empezaremos instalando  react-hot-loader :  yarn add react-hot-loader@next --dev  modificaremos el  webpack.config.js  para activarlo:  entry: [\n    'react-hot-loader/patch',\n    // activate HMR for React\n\n    './src/index.js',\n    // the entry point of our app\n]  Por \u00faltimo debemos modificar nuestro punto de entrada para que utilice el  AppContainer  de  react-hot-loader  que ser\u00e1\nel encargado de mantener el estado de nuestra aplicaci\u00f3n. El componente ra\u00edz de la aplicaci\u00f3n deber\u00e1 estar contenido dentro\ndel componente  AppContainer :  const render = Component =  {\n    ReactDOM.render(\n         AppContainer \n             Component / \n         /AppContainer ,\n        rootElement\n    )\n}\n\nrender(App)\n\nif (module.hot) {\n    module.hot.accept('./App', () =  { render(App) })\n}  De esta manera si realizamos el proceso anterior, modificando el estado de nuestro componente y a su vez modificamos el c\u00f3digo\npara que actue HMR, veremos como el estado del componente se mantiene tras la actualizaci\u00f3n.", 
            "title": "react-hot-loader"
        }, 
        {
            "location": "/react/#referencias", 
            "text": "https://thesabbir.com/hot-reloading-react-stateless-components/", 
            "title": "Referencias"
        }
    ]
}